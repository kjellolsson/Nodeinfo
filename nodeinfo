#!/usr/bin/env python2.7

import os, sys, re, time
import pexpect
import json
import getpass
from subprocess import Popen, PIPE, CalledProcessError
from wiggler.wiggler import Wiggler
from docopt import docopt

pname = os.path.basename(sys.argv[0])
usage = \
'''
    Usage:
        {} [-w | --wigg] (-n | --node) <node_with_info> 
        {} [-w | --wigg] <node_with_info>
        {} [-w | --wigg]:   print full wiggles node info
        {} -v | --version
        {} -h | --help

    Return info about specified node
'''.format(pname,pname, pname, pname, pname)
_version = '0.9'
wigg_base = 'https://wiggles.geo.apple.com/api/v1'

def do_cmd(command):
    """ Executes specified command line """
    try:
        proc = Popen(args=command, stdout=PIPE, stderr=PIPE, shell=True)
        (stdout, stderr) = proc.communicate()
        exit_code = proc.returncode
        
        if exit_code != 0:
            sys.stderr.write('Error executing command: {}\n'.format(command))
            sys.stderr.write('Error code: {}\n'.format(exit_code))
            return ""
        if stderr:
            sys.stderr.write('Error executing command: {}\n'.format(command))
            sys.stderr.write(stderr + '\n')
            return ""
        return stdout.strip()
    except OSError as e:
        sys.stderr.write(e.message + '\n')
    except CalledProcessError as e:
        sys.stderr.write(e.message + '\n')

class wig_class(Wiggler):
    def __init__(self, node):
        self.node_name = node

    def get_wiggler_info(self, pr_all):
        """ Get's the info from the Wiggler base addesaa """
        try:
            cmd = 'curl -s %s/nodes/%s | python -m json.tool' % (wigg_base, self.node_name)
            stdout = do_cmd(cmd)
            if pr_all:
                print(stdout)
            self.apps = json.loads(stdout)['node']['apps']
            self.os_release = json.loads(stdout)['node']['os_release']
            self.environment = json.loads(stdout)['node']['environment']
            self.datacenter = json.loads(stdout)['node']['datacenter']
            self.groups = json.loads(stdout)['node']['groups']
            self.os_name = json.loads(stdout)['node']['os_name']
            self.manufact = json.loads(stdout)['node']['model']['manufacturer'].strip()
            self.model = json.loads(stdout)['node']['model']['productname']
            self.status = json.loads(stdout)['node']['status']
            self.type_ = json.loads(stdout)['node']['type']
            self.updated_at = json.loads(stdout)['node']['updated_at']
            self.members = []
            self.n_members = 0
            if '"members":' in stdout:
                # self.members = json.dumps(json.loads(stdout)['node']['cluster']['members'])
                self.members = json.loads(stdout)['node']['cluster']['members']
                self.n_members = len(self.members)
        except Exception as e:
            print('get_wigglet_info(): Exception occured!!')
            print("%s " % e)
            print('stdout = {}'.format(stdout))
            sys.exit()

    def get_kickstart(self):
        """ Get's the ip address of the kickstart server """
        cmd = "vd expand %s| grep kickstart.server.ip.address | awk -F = '{print $2}'" % (self.node_name)
        stdout = do_cmd(cmd)
        self.kickstart_ip = stdout

    def get_active_releases(self):
        """ Get's the active releases """
        cmd = 'curl -s %s/nodes/%s/status | python -m json.tool' % (wigg_base, self.node_name)
        stdout = do_cmd(cmd)
        self.active_releases = json.loads(stdout)['active_releases']

    def get_local_data(self):
        """ Get's the image release and the disk type """
        try:
            prompt = ' ~\]\$'
            conn = pexpect.spawn('ssh ' + self.node_name)
            match = conn.expect([prompt, '(yes/no)', 'password', pexpect.TIMEOUT, pexpect.EOF])
            if match == 1:
                conn.sendline('yes')
                match = conn.expect([prompt, 'password'])
                if match == 1:
                    passwd = getpass.getpass('node is asking for password. please specify password: ')
                    conn.sendline(passwd+'\n')
                    match = conn.expect([prompt, 'try again'])
                    if match == 1:
                        print('did not accept password. exiting...')
                        sys.exit()
            elif match == 2:
                passwd = getpass.getpass('node is asking for password. please specify password: ')
                conn.sendline(passwd+'\n')
                match = conn.expect([prompt, 'try again'])
                if match == 1:
                    print('did not accept password. exiting...')
                    sys.exit()
            elif match > 2:
                print('No response from {}: Exiting...'.format(self.node_name))
                sys.exit()
            conn.expect([prompt, pexpect.TIMEOUT], timeout=1)
            conn.sendline('cat /etc/motd')
            match = 1
            self.image_ver = ''
            self.disk_layout = ''
            while match == 1:
                match = conn.expect([prompt,'\r\n'])
                if re.search('Image:', conn.before):
                    self.image_ver = re.sub('Image: ([^ ]*) .*','\\1', conn.before)
                    self.disk_layout = re.sub('Image: [^ ]* Disk Layout: (.*)','\\1', conn.before)
            if not self.image_ver:
                self.image_ver = 'Unknown'
            if not self.disk_layout:
                self.disk_layout = 'Unknown'

            # find and run healthcheck
            conn.sendline('sudo find /opt/geo -name healthcheck')
            conn.expect(prompt)
            self.hcbuf = conn.before.split('\n')
            conn.sendline('sudo su worun')
            conn.expect('\]\$')
            self.healthcheck = []
            n = 0
            for line in self.hcbuf[1:]:
                line = line.strip()
                if 'healthcheck' not in line:
                    continue
                self.healthcheck.append([])
                self.healthcheck[n].append([])
                self.healthcheck[n].append([])
                self.healthcheck[n][0] = line.strip()
                conn.sendline(line)
                conn.expect('\]\$')
                if 'OK' in conn.before:
                    self.healthcheck[n][1] = 'OK'
                else:
                    self.healthcheck[n][1] = 'NOT OK'
                n += 1
            conn.sendline('exit')
            conn.expect(prompt)

            # list internal and external hidden status
            self.hidden_status = []
            n = 0
            for app in self.apps:
                conn.expect([prompt, pexpect.TIMEOUT], timeout=1)
                conn.sendline('find /opt/geo/data/{} -name *hidden'.format(app))
                conn.expect(prompt)
                found = conn.before.split('\n')[1:-1]
                for ffile in found:
                    conn.sendline('cat ' + ffile)
                    conn.expect(prompt)
                    status = conn.before.split('\n')[1]
                    self.hidden_status.append([])
                    self.hidden_status[n].append(app.strip())
                    self.hidden_status[n].append(os.path.basename(ffile.strip()))
                    self.hidden_status[n].append(status.strip())
                    conn.expect([prompt, pexpect.TIMEOUT], timeout=1)
                    n += 1

            # look for ps-tatus of monit
            conn.sendline('ps -ef | grep monit')
            conn.expect(prompt)
            self.ps_out = '\n'.join(conn.before.split('\n')[:-1])

            # list /opt/geo
            conn.sendline('ls -l /opt/geo')
            conn.expect(prompt)
            self.ls_out = '\n'.join(conn.before.split('\n')[:-1])

            # run monit
            conn.sendline('sudo monit -B status')
            conn.expect(prompt)
            monit_out = conn.before.split('\n')[1:]

            self.monit_out = []
            for ix in range(len(monit_out)):
                if 'uptime:' in monit_out[ix]:
                    self.monit_out.append(monit_out[ix])
                    self.monit_out.append("")
                if 'Process' in monit_out[ix]:
                    self.monit_out.append(monit_out[ix])
                if 'System' in monit_out[ix]:
                    self.monit_out.append(monit_out[ix])
                if 'status' in monit_out[ix]:
                    self.monit_out.append(monit_out[ix])
                if 'mode' in monit_out[ix]:
                    self.monit_out.append(monit_out[ix])
                    self.monit_out.append("")
            
            # exit connection
            conn.sendline('exit')

        except pexpect.TIMEOUT:
            sys.stderr.write('Pexpect Timeout received\n')
            sys.stderr.write(str(conn)+'\n')
        except pexpect.EOF:
            sys.stderr.write('Pexpect EOF received\n')
            sys.stderr.write(str(conn)+'\n')
        except pexpect.ExceptionPexpect as e:
            sys.stderr.write('Pexpect exception received')
            sys.stderr.write(e.message)
            sys.stderr.write(str(conn)+'\n')

#------------------------
# main section
#------------------------
def main():

    prms = docopt(usage, version = _version)
    node_with_info = prms['<node_with_info>']
    pr_all = False
    if prms['-w'] or prms['--wigg']:
        pr_all = True
    wig_obj = wig_class(node_with_info)
    wig_obj.get_kickstart()
    wig_obj.get_wiggler_info(pr_all)
    wig_obj.get_active_releases()
    wig_obj.get_local_data()
    print('kickstart ip = {}'.format(wig_obj.kickstart_ip))
    print('apps = {}'.format(wig_obj.apps))
    print('active_releases = {}'.format(wig_obj.active_releases))
    print('environment = {}'.format(wig_obj.environment))
    print('datacenter = {}'.format(wig_obj.datacenter))
    print('groups = {}'.format(wig_obj.groups))
    print('os_name = {}'.format(wig_obj.os_name))
    print('os_release = {}'.format(wig_obj.os_release))
    print('image_ver = {}'.format(wig_obj.image_ver))
    print('disk_layout = {}'.format(wig_obj.disk_layout))
    print('model = {}'.format(wig_obj.model))
    print('manufacturer = {}'.format(wig_obj.manufact))
    print('status = {}'.format(wig_obj.status))
    print('type = {}'.format(wig_obj.type_))
    print('updated_at = {}'.format(wig_obj.updated_at))
    if wig_obj.n_members < 15:
        print('members = {}'.format(wig_obj.members))
    print('n_members = {}'.format(wig_obj.n_members))
    print('')
    print(wig_obj.ls_out)
    print('')
    print(wig_obj.ps_out)
    print('')
    for ix in range(len(wig_obj.healthcheck)):
        print('{} --> {}'.format(wig_obj.healthcheck[ix][0],wig_obj.healthcheck[ix][1]))
    print('')
    for ix in range(len(wig_obj.hidden_status)):
        print('{} --> {} --> {}'.format(wig_obj.hidden_status[ix][0],wig_obj.hidden_status[ix][1] ,wig_obj.hidden_status[ix][2]))
    print('')
    for line in wig_obj.monit_out:
        print(line)

if __name__ == '__main__':
    main()
